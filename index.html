<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Interactive AR Chat</title>
  <style>
    /* Overall layout and chat styles (from first code) */
    body {
      margin: 0;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      background: linear-gradient(180deg, #eef2f3, #cfd9df);
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    #container {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 90%;
      max-width: 1200px;
    }
    #heart-container {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      width: 100%;
      height: 100%;
    }
    #chat-section {
      flex: 1;
      text-align: left;
      padding: 20px;
      max-width: 500px;
    }
    #chat-section h2 {
      font-size: 24px;
      font-weight: bold;
      color: #333;
      margin-bottom: 10px;
    }
    .chat-input-bar {
      display: flex;
      align-items: center;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 25px;
      padding: 5px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    }
    .chat-input-bar input {
      flex: 1;
      padding: 8px;
      border-radius: 20px;
      border: none;
      background: transparent;
      color: black;
      font-size: 14px;
      outline: none;
    }
    .send-button {
      background: transparent;
      border: none;
      cursor: pointer;
      padding: 8px;
    }
    .send-button img {
      width: 20px;
      height: 20px;
    }
    #chat-response-container {
      margin-top: 15px;
      padding: 10px;
      max-width: 80%;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.9);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      font-size: 16px;
      color: black;
      line-height: 1.4;
      text-align: left;
      display: none;
    }
    .thinking-animation {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 5px;
      padding: 10px;
    }
    .thinking-animation span {
      width: 8px;
      height: 8px;
      background-color: black;
      border-radius: 50%;
      opacity: 0.6;
      animation: bounce 1.5s infinite ease-in-out;
    }
    @keyframes bounce {
      0%, 80%, 100% { transform: translateY(0); opacity: 0.6; }
      40% { transform: translateY(-6px); opacity: 1; }
    }
    /* Three.js and AR-specific styles (from second code) */
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    #ARButton {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
    }
    .controls {
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      gap: 10px;
    }
    .controls button {
      padding: 10px;
      background: rgba(255, 255, 255, 0.8);
      border: none;
      border-radius: 5px;
    }
  </style>
  <!-- Three.js import map (using the versions from your second code snippet) -->
  <script type="importmap">
  {
      "imports": {
          "three": "https://unpkg.com/three@0.132.2/build/three.module.js",
          "three/examples/jsm/loaders/GLTFLoader": "https://unpkg.com/three@0.132.2/examples/jsm/loaders/GLTFLoader.js",
          "three/examples/jsm/environments/RoomEnvironment": "https://unpkg.com/three@0.132.2/examples/jsm/environments/RoomEnvironment.js",
          "three/examples/jsm/webxr/ARButton": "https://unpkg.com/three@0.132.2/examples/jsm/webxr/ARButton.js"
      }
  }
  </script>
</head>
<body>
  <div id="container">
    <!-- AR Scene Container using Three.js -->
    <div id="heart-container">
      <!-- The Three.js renderer's canvas and AR UI will be injected here -->
      <div class="controls" id="controls">
        <button id="rotateLeft">↶</button>
        <button id="rotateRight">↷</button>
        <button id="zoomIn">+</button>
        <button id="zoomOut">-</button>
      </div>
    </div>
    <!-- Chat Section remains unchanged -->
    <div id="chat-section">
      <h2>Ask me about Broken Heart Syndrome...</h2>
      <div class="chat-input-bar">
        <input type="text" id="user-message" placeholder="Type your question..." onkeypress="handleKeyPress(event)">
        <button class="send-button" onclick="sendMessage()">
          <img src="https://cdn-icons-png.flaticon.com/512/786/786205.png" alt="Send">
        </button>
      </div>
      <div id="chat-response-container">
        <div id="thinking-animation" class="thinking-animation" style="display: none;">
          <span></span><span></span><span></span>
        </div>
      </div>
    </div>
  </div>

  <!-- Three.js AR Script -->
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
    import { RoomEnvironment } from 'three/examples/jsm/environments/RoomEnvironment';
    import { ARButton } from 'three/examples/jsm/webxr/ARButton';

    let camera, scene, renderer, model;
    let controller;
    let reticle;
    let hitTestSource = null;
    let hitTestSourceRequested = false;
    let placedModel = null;
    let isModelPlaced = false;

    // Controls state
    const rotationSpeed = 0.1;
    const scaleSpeed = 0.1;
    
    init();
    animate();

    function init() {
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      // Append the renderer canvas to the heart-container instead of the body
      document.getElementById('heart-container').appendChild(renderer.domElement);

      // Add AR button and append it to the heart-container
      const arButton = ARButton.createButton(renderer, {
        requiredFeatures: ['hit-test'],
        optionalFeatures: ['dom-overlay'],
        domOverlay: { root: document.getElementById('heart-container') }
      });
      arButton.id = "ARButton";
      document.getElementById('heart-container').appendChild(arButton);

      // Lights
      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      light.position.set(0.5, 1, 0.25);
      scene.add(light);

      // Environment
      const pmremGenerator = new THREE.PMREMGenerator(renderer);
      const environmentMap = pmremGenerator.fromScene(new RoomEnvironment()).texture;
      scene.environment = environmentMap;

      // Create reticle for hit-testing
      reticle = new THREE.Mesh(
        new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
        new THREE.MeshBasicMaterial()
      );
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);

      // Load the 3D heart model
      const loader = new GLTFLoader();
      loader.load(
        './reheart.glb',
        (gltf) => {
          model = gltf.scene;
          model.scale.set(0.5, 0.5, 0.5);
          model.visible = false;
        },
        (progress) =>
          console.log('Loading progress:', (progress.loaded / progress.total * 100) + '%'),
        (error) => console.error('Error loading model:', error)
      );

      // Set up AR controller for placing the model
      controller = renderer.xr.getController(0);
      controller.addEventListener('select', onSelect);
      scene.add(controller);

      // Set up on-screen controls for rotation and scaling
      setupControls();

      window.addEventListener('resize', onWindowResize, false);
    }

    function setupControls() {
      const controls = document.getElementById('controls');

      document.getElementById('rotateLeft').addEventListener('click', () => {
        if (placedModel) {
          placedModel.rotation.y += rotationSpeed;
        }
      });

      document.getElementById('rotateRight').addEventListener('click', () => {
        if (placedModel) {
          placedModel.rotation.y -= rotationSpeed;
        }
      });

      document.getElementById('zoomIn').addEventListener('click', () => {
        if (placedModel) {
          placedModel.scale.multiplyScalar(1 + scaleSpeed);
        }
      });

      document.getElementById('zoomOut').addEventListener('click', () => {
        if (placedModel) {
          placedModel.scale.multiplyScalar(1 - scaleSpeed);
        }
      });

      renderer.xr.addEventListener('sessionstart', () => {
        controls.style.display = 'flex';
      });

      renderer.xr.addEventListener('sessionend', () => {
        controls.style.display = 'none';
      });
    }

    function onSelect() {
      if (reticle.visible && model && !isModelPlaced) {
        // Place the model at the reticle position
        placedModel = model.clone();
        placedModel.position.setFromMatrixPosition(reticle.matrix);
        placedModel.visible = true;
        scene.add(placedModel);
        
        // Hide the reticle after placing the model
        reticle.visible = false;
        isModelPlaced = true;
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      renderer.setAnimationLoop(render);
    }

    function render(timestamp, frame) {
      if (frame) {
        const referenceSpace = renderer.xr.getReferenceSpace();
        const session = renderer.xr.getSession();

        if (!hitTestSourceRequested) {
          session.requestReferenceSpace('viewer').then((refSpace) => {
            session.requestHitTestSource({ space: refSpace }).then((source) => {
              hitTestSource = source;
            });
          });
          hitTestSourceRequested = true;
        }

        if (hitTestSource && !isModelPlaced) {
          const hitTestResults = frame.getHitTestResults(hitTestSource);
          if (hitTestResults.length) {
            const hit = hitTestResults[0];
            reticle.visible = true;
            reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
          } else {
            reticle.visible = false;
          }
        }
      }
      renderer.render(scene, camera);
    }
  </script>

  <!-- Chat Functionality Script (remains the same) -->
  <script>
    function handleKeyPress(event) {
      if (event.key === "Enter") {
        sendMessage();
      }
    }

    function sendMessage() {
      const userMessage = document.getElementById("user-message").value;
      const chatResponseContainer = document.getElementById("chat-response-container");
      const thinkingAnimation = document.getElementById("thinking-animation");

      if (userMessage) {
        // Clear previous response
        chatResponseContainer.innerHTML = "";
        chatResponseContainer.style.display = "block";

        // Show thinking animation
        thinkingAnimation.style.display = "flex";
        chatResponseContainer.appendChild(thinkingAnimation);

        // Call the AI chat API
        getChatResponse(userMessage);

        // Clear the input field
        document.getElementById("user-message").value = "";
      }
    }

    async function getChatResponse(userMessage) {
      const response = await fetch("https://ari-b6xq.onrender.com/chat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ message: userMessage })
      });

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let finalResponse = "";
      const chatResponseContainer = document.getElementById("chat-response-container");
      const thinkingAnimation = document.getElementById("thinking-animation");

      // Remove thinking animation placeholder
      chatResponseContainer.innerHTML = "";
      chatResponseContainer.style.display = "block";

      // Create a chat bubble for the response
      const chatBubble = document.createElement("div");
      chatBubble.classList.add("chat-bubble");
      chatBubble.innerText = "Thinking...";
      chatResponseContainer.appendChild(chatBubble);

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        finalResponse += decoder.decode(value);
        chatBubble.innerText = finalResponse;
      }

      thinkingAnimation.style.display = "none";
    }
  </script>
</body>
</html>
